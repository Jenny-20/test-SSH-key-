==
第一天上午(1)
ctrl+Enter:快速填充,批量填充
ctrl+n:新建一个工作薄
ctrl+向下键/ctrl+end/鼠标双击下边框:到工作表最底端(1048576)
ctrl+右键/鼠标双击右边框:到工作表最右端(16384)
ctrl+Home/鼠标双击上边框:快速返回A1
ctrl+page up/ctrl+page down:工作表切换快捷键
ctrl+shift+向下键:选中图表中列的数据(数据的单元格不为空,遇空则断)
ctrl+shift+向上键:选中图表中列的数据
ctrl+shift+向右键:选中图表中行的数据(数据的单元格不为空,遇空则断)
ctrl+向右键:选中图表中行的最后一个数据
(ctrl+shift+向下键+向右键)/(选中数据+ctrl+A):全选数据
Alter+enter:单元格内部换行
shift+向右键:选中右边单元格和原单元格
ctrl+; :当前时间 ,F9刷新
求和快捷键: alt+=

第一天上午(2)
1.表头居中:选择适合工作表的表头长度,在开始->字体选项栏中选择对齐->水平居中选项卡中选择"跨列居中"

2.文件保护:
1)密码加密: 文件->信息->保护工作薄->用密码进行加密
2)标记为最终状态,以防工作薄被编辑(还可以被更改):文件->信息->保护工作薄->标记为最终状态
3)保护工作表内容,及锁定单元格内容(行和列):审阅->保护工作表
4)保护工作表结构(新建删除工作表):审阅->保护工作表薄->结构
5)隐藏公式:(字体/对齐方式/数字) 选项栏->保护->(锁定.隐藏)仅仅是标记->审阅->保护工作表

3.打印:
1)视图->分页预览->拖动分页符到合适的地方(添加分页符必须在第一列单元格上插入"页面布局->分隔符->插入分隔符")
  分页打印:视图->分页预览->页面布局->分隔符->插入分隔符
2)打印标题:页面布局->打印标题->顶端标题行
3)不打印图片:开始->1.查找和选择->选择窗格->关闭图片的显示
		图片->设置单元格格式=>属性->取消打印对象

4.将数据与数据库断开链接:数据->链接->删除

第一天下午:
1.求和快捷键: alt+=
2.激活文本型数字:选中要更改的单元格,点击左上角有一个黄色的感叹号,选定"转化为数字
3为什么有文本型数字(不能进行计算):ecxel最大精度为15位,通常在输入前用单引号区分('1999),或者在开始->数字->文本,
4.表格转置:选中数据,复制,选择性粘贴,转置
5.选择性粘贴中跳过空单元格的应用-数据合并:选中数据->复制->选择性粘贴->跳过单元格->复制->复制为图片(外观如图片所示,格式图片)
6.在Excel查找替换:
	1)* 任意多个字符,没有指定字符长度
	2)? 任意单个字符
	3)~*: * 号本身
	4)~?: ?号本身
	5)~~:~号 本身
	6)替换空格要在键盘为英文事输入空格键(替换时一定要选中要替换的数据表)
	7)*王*:通配符,将文字中带有"王"的替换
	8)替换单元格只有一个A:替换A->选项->单元格匹配
7.删除空白地址所在的行:查找和选择->定位条件->空值->单元格->删除->删除工作表行
8.定位公式:查找和选择->定位条件->公式
9.连接数据;&
10.分割数据:复制->粘贴->取消格式(公式)保留值-> 数据->分列->固定宽度->固定宽度
11.把区号和电话分开:数据->分列->分割符号->其他"-"->"021"设置为文本格式
12.合并计算:

第一天下午(2)
1.Excel中单元格的几种类型:
	1.文本类型,默认左对齐:文字,字母,符号,文本型数字
	2.数值型:默认右对齐
	3.逻辑值,默认居中对齐,TRUE (1), FALSE (0)
	4.日期和时间默认右对齐
2.自定义的格式代码具有以下结构：
	1.正数;负数;零值;文本 （分号为英文符号）
		利用条件格式4个区域的定义，在分号间不输入代码，用户可以对各区域内容如：正数、负数、零值或文本进行隐藏
	2.[颜色]:可供选择的颜色代码有：
		[黑色]、[白色]、[蓝色]、[红色]、[黄色]、[绿色]、[洋红]，
		颜色的两边必须加上英文方括号， 颜色一定要用中括号括起来
	3.G/通用格式:正常显示
	4.[颜色][条件]G/通用格式
	5._%:不转义%
	6._:对齐
	7.在自定义数字格式中，0作为数字占位符，当数字比代码的数量少时，显示无意义的0
	8.占位符0作用于小数时，小数位数多于0的数量，自动四舍五入至0的数位，小数位数小于0的数量，补上0占位
	9.在自定义数字格式中，＃作为数字占位符，只显示有意义的数值，不显示无意义的0，
	10.@ 文本
	11.*+空格:中间留空
	12. , :千位分隔符
	13.!. : 小数点 (.在自定义中不是小数点,!是强制转换)
	14.在自定义数字格式中，？也是数字占位符，跟0很相似，但？以空格代替0，可用于小数点对齐及分数显示
	15.可以用英文引号""中加入文本,在文本前后增加数值对文本进行自定义格式，
	16.yyyy"年"m"月"d"日"aaaa: 年月日星期X,(aaaa代表星期X,aaa代表星期X)
	17.在会计中只有千位,百万,十亿(不能除以万位)
	18.在自定义格式代码，表示日期格式的代码见下表，通过改变代码的数量和顺序改变日期的显示方式，见实例十五：									
		年	显示	月	显示	日	显示	星期	显示		上下午		显示
		yyyy	2008	mmm	May	dd	08	aaaa	星期四		上午/下午	下午
		yy	08	mm	05	d	8	aa	四		AM/PM		PM
		y	08	m	5			dddd	Thursday	a/p		p

	19.在自定义格式代码，表示时间格式的代码为：h表示时、m表示分、s表示秒，见实例十六：
		原数据		自定义格式代码				定义后		
		10:11:27	hh"时"mm"分"ss"秒"			10时11分27秒		
		10:11:27	h:mm AM/PM				10:11 AM		
		10:11:27	上午/下午 hh-mm-ss			上午 10/11/27		
		10:11:27	上午/下午　hh点mm分ss秒			上午 10点11分27秒		


	20.EXCEL中文版中，自定义数字格式里还有3个特殊的数字格式，即中文小写、中文大写、全角数字与中文结合三种形式。
	20.条件格式中包含一些中间文本可以用(="文本")

第二天上午(1)
1.隐藏文件后缀:组织->文件夹选项->隐藏已知文件的拓展名
2.导入xml数据源:数据->获取外部数据->自其他来源->来自其他XML数据导入
3.导入txt文件:数据->获取外部数据->自文本->(导入分布向导)
4.导入自网站:数据->获取外部数据->自网站->单击"->" ->导入

第二天上午(2)
1.删除重复项:数据->数据工具->删除重复值 (所有记录彻底删除)
2.删除重复项:数据->筛选->高级(选择"选择不重复的记录)
3.冻结窗格:视图->窗口->冻结窗格
4.单元格名称命名:
		1.公式->定义的名称->名称管理器
		2.名称栏中修改
		3.根据所选内容创建:公式->定义的名称->根据所选内容创建->
5.通过单元格名称进行计算
6.函数表达式
	符号名	数学中的写法		Excel公式中的写法
	加号		+		+
	减号		-		-
	乘号		×		*
	除号		÷		/
	平方		42		4^2
	三次方		43		4^3
	开方				5^0.5
	开三次方			5^(1/3)
	大、中、小括号	{[(2+2)×2+2]×2+2}×2	(((2+2)*2+2)*2+2)*2
	等于		=		=
	不等于		≠		<>
	大于		>		>
	小于		<		<
	大于等于	≥		>=
	小于等于	≤		<=

 运算优先顺序			
	括号（）→百分比%→乘方^ → 乘*、除// → 加+、减		
7.单元格引用:
	相对引用和绝对引用：按F4切换引用方式。					
	相对引用:	A1	复制、粘贴公式时行、列都变化			
	绝对引用:	$A$1	复制、粘贴公式时行、列都不变化			
	行绝对引用:	A$1	复制、粘贴公式时行不变化，列变化			
	列绝对引用:	$A1	复制、粘贴公式时行变化，列不变化			
	
	往下拖动锁数字,往右拖动锁字母

8.错误	常见原因	处理方法
#DIV/0!	在公式中有除数为零，或者有除数为空白的单元格(Excel把空白单元格也当作0)。	把除数改为非零的数值，或者用IF函数进行控制。
#N/A	在公式使用查找功能的函数(VLOOKUP、HLOOKUP、LOOKUP等)时，找不到匹配的值。	检查被查找的值，使之的确存在于查找的数据表中的第一列。
#NAME?	在公式中使用了Excel无法识别的文本，例如函数的名称拼写错误，使用了没有被定义的区域或单元格名称，引用文本时没有加引号等。	根据具体的公式，逐步分析出现该错误的可能，并加以改正。
#NUM!	当公式需要数字型参数时，我们却给了它一个非数字型参数；给了公式一个无效的参数；公式返回的值太大或者太小。	根据公式的具体情况，逐一分析可能的原因并修正。
#VALUE	文本类型的数据参与了数值运算，函数参数的数值类型不正确；	更正相关的数据类型或参数类型；
	函数的参数本应该是单一值，却提供了一个区域作为参数；		提供正确的参数；
	输入一个数组公式时，忘记按Ctrl＋Shift＋Enter键。	输入数组公式时，记得使用Ctrl＋Shift＋Enter键确定。
#REF!	公式中使用了无效的单元格引用。通常如下这些操作会导致公式引用无效的单元格：删除了被公式引用的单元格；把公式复制到含有引用自身的单元格中。	避免导致引用无效的操作，如果已经出现错误，先撤销，然后用正确的方法操作。
#NULL!	使用了不正确的区域运算符或引用的单元格区域的交集为空。	改正区域运算符使之正确；更改引用使之相交。

9.常用函数
	最大值  MAX()

	最小值  MIN()

	第N大值 LARGE(区域或数组，N)

	第N小值 SMALL(区域或数组，N)

	平均值 AVERAGE()

	排名 RANK()需要排名的单元格,实际排名的区域

	ROUND(区域或数组,返回小数点后第几位) 函数可将某个数字四舍五入为指定的位数,能进行四舍五入

	INT(number) 将数字向下舍入到最接近的整数。不能进行四舍五入

	COUNT()  返回包含数字以及包含参数列表中的数字的单元格的个数。(包括数值0)
		利用COUNT函数可以计算单元格区域或数字数组中数字字段的输入项个数。

	COUNTA() 返回参数列表中非空值的单元格个数。包含文本
		利用函数COUNTA可以计算单元格区域或数组中包含数据的单元格个数。

	COUNTBLANK() 返回参数列表中空值的单元格个数。
		利用函数COUNTBLANK可以计算单元格区域或数组中包含空格的单元格个数。
	
	PRODUCT() 计算所有参数的乘积

	SUMPRODUCT(array1,array2,array3, ...) 在给定的几组数组中，将数组间对应的元素相乘，并返回乘积之和。
					数组参数必须具有相同的维数，否则，函数 SUMPRODUCT 将返回错误值 #VALUE!。
					函数 SUMPRODUCT 将非数值型的数组元素作为 0 处理。 

10.逻辑值:
	(1)TRUE(FALSE)
		TRUE :逻辑值“真”
		FALSE:逻辑值“假”

		通过比较运算，函数运算可以得到TRUE或者FALSE值
		当TRUE和FALSE参与数学运算和部分函数运算时，TRUE作为1，FALSE作为0
		当用其他数字来代替逻辑值作为函数参数时，0代表FALSE，其他数字代表TRUE

	(2)AND(OR)函数
	AND相当于所有的参数做乘法（逻辑乘），OR相当于所有的参数做加法（逻辑加）

		AND(logical1,logical2, ...):所有参数的逻辑值为真时，返回 TRUE；只要一个参数的逻辑值为假，即返回 FALSE。
			Logical1, logical2, ...    表示待检测的 1 到 30 个条件值，各条件值可为 TRUE 或 FALSE

		OR(logical1,logical2, ...):在其参数组中，任何一个参数逻辑值为 TRUE，即返回 TRUE；任何一个参数的逻辑值为 FALSE，即返回 FALSE。
			Logical1, logical2, ...    表示待检测的 1 到 30 个条件值，各条件值可为 TRUE 或 FALSE

	说明										
		AND		参数必须是逻辑值 TRUE 或 FALSE, 或者包含逻辑值的数组或引用。 								
				如果数组或引用参数中包含文本或空白单元格，则这些值将被忽略。 								
				如果指定的单元格区域内包括非逻辑值，则 AND 将返回错误值 #VALUE!。 
				
		OR		参数必须能计算为逻辑值，如 TRUE 或 FALSE，或者为包含逻辑值的数组或引用。 								
				如果参数为数组或引用，则只使用数组或引用中的数值。忽略数组或引用中的空白单元格和文本值。 								
				如果指定的区域中不包含逻辑值，函数 OR 返回错误值 #VALUE!。 								
				可以使用 OR 数组公式来检验数组中是否包含特定的数值。若要输入数组公式，请按 Ctrl+Shift+Enter。 
	
11.IF函数
		执行真假值判断，根据逻辑计算的真假值，返回不同结果。可以使用函数 IF 对数值和公式进行条件检测。

		语法									
		IF(logical_test,value_if_true,value_if_false)									
			(1) Logical_test    表示计算结果为 TRUE 或 FALSE 的任意值或表达式。								
			(2) Value_if_true    logical_test 为 TRUE 时返回的值。如果 logical_test 为 TRUE 而 value_if_true 为空，则本参数返回 0（零）。								
			(3) Value_if_false    logical_test 为 FALSE 时返回的值。如果 logical_test 为 FALSE 且忽略了 Value_if_false（即 value_if_true 后没有逗号），则会返回逻辑值 FALSE。								

		说明									
		函数 IF 可以嵌套七层，用 value_if_false 及 value_if_true 参数可以构造复杂的检测条件。								
		在计算参数 value_if_true 和 value_if_false 后，函数 IF 返回相应语句执行后的返回值。 								
		如果函数 IF 的参数包含数组，则在执行 IF 语句时，数组中的每一个元素都将计算。 
	
12.COUNTIF(range,criteria)单条件计数
		(1) Range    为需要计算其中满足条件的单元格数目的单元格区域。								
		(2) Criteria    为确定哪些单元格将被计算在内的条件，其形式可以为数字、表达式或文本。例如，条件可以表示为 32、"32"、">32" 或 "apples"。
		如果用或就是countif+,如果是且就用countifs
		
13.COUNTIFS(COUNTIF_range1,criteria1,COUNTIF_range2,criteria2...)多条件计数
		(1) COUNTIF_Range1    为需要计算其中满足条件的单元格数目的单元格区域。								
		(2) Criteria1    为确定哪些单元格将被计算在内的条件，其形式可以为数字、表达式或文本。								
		(3) COUNTIF_Range2    为需要计算其中满足条件的单元格数目的单元格区域。								
		(4) Criteria2    为确定哪些单元格将被计算在内的条件，其形式可以为数字、表达式或文本。								
		如果用或就是countif+,如果是且就用countifs

14.ctrl+shift+enter 数组公式  :凡是多条件统计,多条件查询,多条件查找 则在公式中用此快捷键,自动添加一对"{}"

15.调试函数:公式->公式审核->公式求值

16.SUMIF(range,criteria,sum_range)根据指定条件对若干单元格求和。
		(1) Range    为用于条件判断的单元格区域。								
		(2) Criteria    为确定哪些单元格将被相加求和的条件，其形式可以为数字、表达式或文本。例如，条件可以表示为 32、"32"、">32" 或 "apples"。（使用方法同COUNTIF）								
		(3) Sum_range    是需要求和的实际单元格。(可只写该区域的第一个单元格）								
		
		说明									
		只有在区域中相应的单元格符合条件的情况下，sum_range 中的单元格才求和。								
		如果忽略了 sum_range，则对区域中的单元格求和。								

17.SUMIFS(SUM_range,criteria1,sum_range1,criteria2,sum_range2,...)根据指定条件对若干单元格求和
		(1) SUM_Range    为用于条件判断的单元格区域。								
		(2) Criteria1    为确定哪些单元格将被相加求和的条件，其形式可以为数字、表达式或文本。例如，条件可以表示为 32、"32"、">32" 或 "apples"。（使用方法同COUNTIF）								
		(3) range1    是需要求和的实际单元格。(可只写该区域的第一个单元格）								

		说明									
		只有在区域中相应的单元格符合条件的情况下，sum_range 中的单元格才求和。								
		如果忽略了 sum_range，则对区域中的单元格求和。
		
18.超过15位要加"*"才能精确计算

19.ROW(reference)   COLUMN相同
	
	Reference    为需要得到其行号的单元格或单元格区域。	
	如果省略 reference，则假定是对函数 ROW 所在单元格的引用。	
	如果 reference 为一个单元格区域，并且函数 ROW 作为垂直数组输入，则函数 ROW 将 reference 的行号以垂直数组的形式返回。	
	Reference 不能引用多个区域。	
	
20.MATCH(查找值,查找区域,逻辑值)函数 MATCH 返回 查找区域 中目标值的位置，而不是数值本身。

	查找值    为需要在数据表中查找的数值。查找值可以是数值、文本或者逻辑值。						
	查找区域    可能包含所要查找的数值的连续单元格区域。查找区域 应为数组或数组引用。						
	逻辑值    逻辑值和VLOOKUP类似，当逻辑值是FALSE或者0的时候，函数进行精确查找;当逻辑值是1或者是-1进行模糊查找。						

	说明						
	查找值		查找值 为需要在 Look_array 中查找的数值。例如，如果要在电话簿中查找某人的电话号码，则应该将姓名作为查找值，但实际上需要的是电话号码。				
			查找值 可以为数值（数字、文本或逻辑值）或对数字、文本或逻辑值的单元格引用。				
	逻辑值		如果 逻辑值 为 1，函数 MATCH 查找小于或等于 查找值 的最大数值。查找区域 必须按升序排列：...、-2、-1、0、1、2、...、A-Z、FALSE、TRUE。模糊查找				
			如果 逻辑值 为 0，函数 MATCH 查找等于 查找值 的第一个数值。查找区域 可以按任何顺序排列。     精确查找				
			如果 逻辑值 为 -1，函数 MATCH 查找大于或等于 查找值 的最小数值。查找区域 必须按降序排列：TRUE、FALSE、Z-A、...、2、1、0、-1、-2、...，等等。   模糊查找				
			逻辑值为1时可以省略第3个参数。	
			
	函数 MATCH 返回 查找区域 中目标值的位置，而不是数值本身。例如，MATCH("b",{"a","b","c"},0) 返回 2，即“b”在数组 {"a","b","c"} 中的相应位置。						
	查找文本值时，函数 MATCH 不区分大小写字母。 						
	如果函数 MATCH 查找不成功，则返回错误值 #N/A。 						
	如果 逻辑值 为 0 且 查找值 为文本，查找值 可以包含通配符、星号 (*) 和问号 (?)。星号可以匹配任何字符序列；问号可以匹配单个字符。 						

21.VLOOKUP(查找值,数据区域,返回列数,逻辑值）							
	查找值      是需要在数据区域的第一列中查找的数值，可以为数值、文本、引用或者是公式计算出的结果。只有查找值在数据区域中的第一列存在时，公式才能返回正确的值。如果查找的数值在第一列中不存在，则会返回错误值"#N/A"。						
	数据区域    是包括查找值和返回值在内的区域，一般表示为"$D$23:$F$31"的形式，以便于公式填充，也可以将区域定义为一个名称。						
	返回列数    在数据区域的第一列找到查找值后，返回查找值对应的哪一行的第几列的单元格的内容。						
	逻辑值    指明函数 VLOOKUP 返回时是精确匹配还是近似匹配。						

	说明										
	"Table_array
	参数"		如果 range_lookup 为 TRUE，则 table_array 的第一列中的数值必须按升序排列：…、-2、-1、0、1、2、…、-Z、FALSE、TRUE；否则，函数 VLOOKUP 不能返回正确的数值。如果 range_lookup 为 FALSE，table_array 不必进行排序。								
			通过在“数据”菜单中的“排序”中选择“升序”，可将数值按升序排列。								
			Table_array 的第一列中的数值可以为文本、数字或逻辑值。								
			文本不区分大小写。
			
	如果函数 VLOOKUP 找不到 lookup_value，且 range_lookup 为 TRUE，则使用小于等于 lookup_value 的最大值。 										
	如果 lookup_value 小于 table_array 第一列中的最小数值，函数 VLOOKUP 返回错误值 #N/A。 										
	如果函数 VLOOKUP 找不到 lookup_value 且 range_lookup 为 FALSE，函数 VLOOKUP 返回错误值 #N/A。 

22.INDEX函数										
	返回指定的行与列交叉处的单元格引用。函数 INDEX() 有两种形式：数组和引用。数组形式通常返回数值或数值数组；引用形式通常返回引用。									
										
	语法									
	INDEX(数据区域,行序号或列序号)						数组形式			
	INDEX(数据区域的引用,行序号,列序号,区域序号)				引用形式			
										
	说明									
	数组形式		"array    为单元格区域或数组常量。
	如果数组只包含一行或一列，则相对应的参数 row_num 或 column_num 为可选。
	如果数组有多行和多列，但只使用 row_num 或 column_num，函数 INDEX 返回数组中的整行或整列，且返回值也为数组。
	Row_num    数组中某行的行序号，函数从该行返回数值。如果省略 row_num，则必须有 column_num。
	Column_num    数组中某列的列序号，函数从该列返回数值。如果省略 column_num，则必须有 "							
				"如果同时使用 row_num 和 column_num，函数 INDEX 返回 row_num 和 column_num 交叉处的单元格的数值。 
	如果将 row_num 或 column_num 设置为 0，函数 INDEX 则分别返回整个列或行的数组数值。若要使用以数组形式返回的值，
	请将 INDEX 函数以数组公式形式输入，对于行以水平单元格区域的形式输入，对于列以垂直单元格区域的形式输入。若要输入数组公式，请按 Ctrl+Shift+Enter。 
	Row_num 和 column_num 必须指向"	数字 1（星期一）到数字 7（星期日）。						
		引用形式		"Reference    对一个或多个单元格区域的引用。
	如果为引用输入一个不连续的区域，必须用括号括起来。
	如果引用中的每个区域只包含一行或一列，则相应的参数 row_num 或 column_num 分别为可选项。例如，对于单行的引用，可以使用函数 INDEX(reference,,column_num)。

	Row_num    引用中某行的行序号，函数从该行返回一个引用。

	Column_num    引用中某列的列序号，函数从该列返回一个引用。

	Area_num    选择引用中的一个区域"							
				"在通过 reference 和 area_num 选择了特定的区域后，row_num 和 column_num 将进一步选择指定的单元格：row_num 1 为区域的首行，column_num 1 为首列，以此类推。函数 INDEX 返回的引用即为 row_num 和 column_num 的交叉区域。 
	如果将 row_num 或 column_num 设置为 0，函数 INDEX 分别返回对整个列或行的引用。

	Row_num、column_num 和 area_num 必须指向 reference "							
										
13.OFFSET函数					
	以指定的引用为参照系，通过给定偏移量得到新的引用。返回的引用可以为一个单元格或单元格区域。并可以指定返回的行数或列数。				
					
	语法				
	OFFSET(reference, rows, cols, [height], [width])				
	Reference  必需。作为偏移量参照系的引用区域。Reference 必须为对单元格或相连单元格区域的引用；否则，OFFSET 返回错误值 #VALUE!。				
	Rows  必需。相对于偏移量参照系的左上角单元格，上（下）偏移的行数。如果使用 5 作为参数 Rows，则说明目标引用区域的左上角单元格比 reference 低 5 行。行数可为正数（代表在起始引用的下方）或负数（代表在起始引用的上方）。				
	Cols  必需。相对于偏移量参照系的左上角单元格，左（右）偏移的列数。如果使用 5 作为参数 Cols，则说明目标引用区域的左上角的单元格比 reference 靠右 5 列。列数可为正数（代表在起始引用的右边）或负数（代表在起始引用的左边）。				
	Height  可选。高度，即所要返回的引用区域的行数。Height 必须为正数。				
	Width  可选。宽度，即所要返回的引用区域的列数。Width 必须为正数。				
					
第三天上午3:
文本函数
1.MID函数	
	从符串中返回指定位置的的文本个数	
		
	语法	
	MID(字符串,开始位置，字符的个数)	
	MID(Text,Start_num，Num_chars)	
		
	Text指定的字符串	
	Start_num开始的文本位置	
	Num_chars指定的文本长度	

2.isodd() 奇数
  iseven() 偶数

第三天下午(1):

1.LEFT(TEXT,Start_num)
	从左边返回指定文本长度的字符串

2.RIGHT(TEXT,Start_num)
	从右边返回指定的文本长度的字符串

3.LEN(TEXT)
	返回文本字符的个数

4.LENB(TEXT)
	返回文本字节个数(中文文字/全角字母=2字节)

5.CODE(text)	
	返回文本字符串中第一个字符的数字代码(单个字母就返回它的ASCII)
	解码: (1) alter+密文+enter
	      (2)CHAR(number)

6.CHAR(number)		
	返回对应于数字代码的字符。
	
8.EXACT [ɪɡ'zækt]函数		
	该函数用于比较两个字符串：如果它们完全相同，则返回 TRUE；否则，返回 FALSE。	
	用"="不能精确比较(文本)		
	语法		
	EXACT(text1, text2)		
			
	EXACT 函数语法具有下列参数 		
	Text1  必需。第一个文本字符串。		
	Text2  必需。第二个文本字符串。
	
9.TEXT函数	
	TEXT 函数可将数值转换为文本，并可使用户通过使用特殊格式字符串来指定显示格式。
	
	语法	
	TEXT(value, format_text)
		value:要转换的文本
		format_text:转换的类型

10.FIND函数	
	返回某个文本在字符串中的位置，区分大小写查找,如果是多个词,则返回第一个文本的位置
	
	语法	
	FIND(find_text, within_text, [start_num])	
		
	Find_text  必需。要查找的文本。	
	Within_text  必需。包含要查找文本的文本。	
	Start_num  可选。指定要从其开始搜索的字符。within_text 中的首字符是编号为 1 的字符。如果省略 start_num，则假设其值为 1。	
	
11.SEARCH [sɝtʃ]函数		
	返回某个文本在字符串中的位置，不区分大小写查找，可以实现模糊查找	
		
	语法		
			
	SEARCH(find_text,within_text,[start_num])		
	find_text  必需。要查找的文本。		
	within_text  必需。要在其中搜索 find_text 参数的值的文本。		
	start_num  可选。within_text 参数中从之开始搜索的字符编号。		

12.SUBSTITUTE函数			
	在文本字符串中用 new_text 替代 old_text。			
				
	语法			
	SUBSTITUTE(text, old_text, new_text, [instance_num])			
				
	Text  必需。需要替换其中字符的文本，或对含有文本（需要替换其中字符）的单元格的引用。			
	Old_text  必需。需要替换的旧文本。			
	New_text  必需。用于替换 old_text 的文本。			
	Instance_num  可选。用来指定要以 new_text 替换第几次出现的 old_text。如果指定了 instance_num，则只有满足要求的 old_text 被替换；否则会将 Text 中出现的每一处 old_text 都更改为 new_text。			

13.REPLACE函数			
	使用其他文本字符串并根据所指定的字符数替换某文本字符串中的部分文本		
			
	语法			
	REPLACE(old_text, start_num, num_chars, new_text)			
				
	Old_text  必需。要替换其部分字符的文本。			
	Start_num  必需。要用 new_text 替换的 old_text 中字符的位置。			
	Num_chars  必需。希望 REPLACE 使用 new_text 替换 old_text 中字符的个数。			
	Num_bytes  必需。希望 REPLACEB 使用 new_text 替换 old_text 中字节的个数。为空时就是插入			
	New_text  必需。将用于替换 old_text 中字符的文本。			

时间函数
14.获得现在的日期与时间是：now() ->2019/4/24 16:29
F9刷新

15 获得现在的日期是：today()->2019/4/24

	16.年份	月份	日	小时	分钟	秒
	YEAR()	MONTH()	DAY()	HOUR()	MINUTE()	SECOND()


17.	WEEKDAY(serial_number,return type)	返回当周第几天	
	serial_number:一个表示返回值类型的数字
	return type:	从星期日=1到星期天=7
			从星期一=1到星期天=7
			从星期一=0到星期天=6


18.	WEEKNUM(serial_number,return type)	返回当年第几周	
		serial_number:用于日期时间计算的时间代码

	DATE()	函数返回表示特定日期的连续序列号	
	DATE(year,month,day)		

19.Eomonth(start_date,month) :返回指定月数之前/之后的月数最后一天		
	start_date:起始日期的日期
	month:start_date之前/之后的日期("0",当前月份,"-1"上一个月份,"1"下一月)

20.netweekdays(start_date,end_date)
		返回两个日期之间的完整工作天数

21.WORKDAY(start_date,day,holidays) 返回指定若干个工作日之前/之后的日期(一段数字)如果需要要将数字转化为日期类型
	start_date:一串表示起始日期的数字
	day:非周末和非假日的天数
	holidays:从工作日历中去除的一个或多个日期(一串数字)的可选组合

22.DATEDIF(开始日期，结束日期，"类型值")	
	
	开始日期	
	日期或可被运算为日期的值或表达试，不能大于结束日期	
		
	结束日期	
	日期或可被运算为日期的值或表达试，不能小于结束日期	
		
	类型值	
	类型值	说明
	y	计算结果是两个日期间隔的年数
	m	计算结果是两个日期间隔的月份数
	d	计算结果是两个日期间隔的天数
	ym	计算结果是两个日期间隔的月份数.不计相差年数
	yd	计算结果是两个日期间隔的天数.忽略年数差
	md	计算结果是两个日期间隔的天数.忽略年数和月份之差(如果结束时间的天数小于开始时间的天数,会屏蔽这个用法)
	
	
第4天
	数据录入存储规范:
	1.提示:数据->数据工具->数据验证->数据验证->输入信息
	2.设置文本长度:数据->数据工具->数据验证->数据验证->设置->允许(文本长度)
	3.下拉列表:数据->数据工具->数据验证->数据验证->设置->允许(序列)->来源(多个使用英文状态下的逗号隔开)
	4.信息纠错:1.数据->数据工具->数据验证->数据验证->设置->允许(整数)
		    2.数据->数据工具->数据验证->圈释无效

第4天上午2
	表格可视化数据:
	1.条件格式应用:
		(1)找出差异值:开始->样式->条件格式->突出显示单元格规则->重复值
			(2)不用时:开始->样式->条件格式->清除规则
		(2)条件求和:视情况而定

	专业大数据与报表分析
	透视表:
	1.让多个透视表不影响:在插入是多新增几行

第4天下午1:

1.N个工作表合并:数据->获取外部数据->现有连接->使用需要的工作薄->导入数据(表)->选择工作薄中的工作表
			    将更多工作表链接:右键->表格->编辑查询->输入SQL语句:
					select * from ['13年9月$']
					union all
					select * from ['13年10月$']
					union all
					select * from ['13年11月$']
					

			     刷新频率:点击外部链接的表格->表格工具->设计->外部数据表->刷新->链接属性
	 
2.N个工作表合并透视:
   (1)数据->获取外部数据->现有连接->使用需要的工作薄->导入数据(数据透视表)
   (2)数据透视表(分析)->数据(更改数据源)->连接属性(定义)->命令文本->输入select * from ['13年9月$']
									union all
									select * from ['13年10月$']
									union all
									select * from ['13年11月$']
							
3.透视表一个标签在多个单元格中居中:数据透视表工具->分析->数据透视表->选项->打印->布局和格式->布局(合并且居中排列带标签的单元格)
4.分组不常置:数据透视表工具->分析->组选择
5插入计算字段:数据透视表工具->分析->计算->字段.项目和集->计算字段
6.学会插入迷你图以及设计

第4天下午1:
规划分析:
1.单变量求解: 数据->模拟分析->单变量求解(目标单元格必须要有公式)
2.放开"规划求解加载项":文件->选项->加载项->点击"规划求解加载项"->转到->加载宏->选择"规划求解加载项"
	遵守约束的条件单元格必须有公式

方案管理:
生成方案管理摘要:设计好了方案后再点击方案摘要

第4天下午2:NO11数据呈现可视化图表技术<<图表之道>>刘万祥

1.商业图表的布局大部分呈竖型结构
   主标题区
	副标题区
	图例区(如果需要)
	绘图区
	脚注区


											
1、专业图表的特点分析																			3、突破Excel默认的颜色
	1.1专业的外观																			3.1普通用户作图表，会受Excel默认的颜色的限制，而无法使用其他颜色。
	他们的图表都制作精良，显得专业协调。我们或许不知道它专业在哪里，但有一点可以确定										这么年大家都用这套颜色作图，看得多了就太熟悉了，别人一看就知道是
	那就是在他们的图表中很少能看到Office软件中默认的颜色、字体和布局。而这些都正是构成										用Excel做的，还会感觉你挺懒的，连默认设置都懒得修改。
	专业外观的重要方面。										
																					而专业人士做图表，他们用色就透露出专业的精神。他们不管用什么软件作图，都
	1.2简洁的类型																			极少会使用软件默认的颜色，而是使用他们自己选定的颜色，形成自己的风格。因此，
	他们的图表都只使用一些最基本的图表类型，绝不复杂。不需要多余的解释，任何人都能看懂										制作专业的图表的第一步，就是要突破Excel的默认颜色
	图表的意思，真正起到了图表的沟通作用。										
																					3.2字体的选择
	1.3明确的观点										
	他们在图表的标题中明白无误的直陈观点，不需要读者再去猜测制图者的意思确保信息传递的										推荐中文字体为：微软雅黑
	高效率，不会出现偏差。																		数字、英文为 ：Arial
																					图表标签一般为7/8号字体
											
	1.4完美的细节										
	请注意他们对每一图表元素的处理，几乎达到完美的程度。一丝不苟之中透露出百分百的严谨										
	好像这不是一份图表，而是一件艺术品。在很大程度上，正是这些无微不至的细节处理，才体										
	现出图表的专业性。而这往往是我们普通图表不会注意到的地方。										
											
2、商业图表的标杆											
	2.1《商业周刊》、《华尔街日报》、《纽约时报》										
	2.2罗兰.贝格、麦肯锡等顶尖的咨询公司										
											
3.精确选择图表属性:格式->当前所选内容
4.调整图表深度和高度:格式->形状样式->效果->三维旋转->取消自动缩放
5.自定义颜色:精细选择要改变的区域->形状样式->形状填充->其他填充->自定义
6.组合图表中多个属性:选中n个边框->"右键"组合->点击组合后的边框拖动

7.复合图:
   多添加一个系列:ctrl+c复制数据源->点中图表crtl+v
8.动态雷达图需要动态的设计 
